uint8_t NES::getInmeditate_u8();
uint8_t NES::getZeroPage_u8();
uint8_t NES::getZeroPageX_u8();
uint16_t NES::getAbsolute_u16();
uint16_t NES::getAbsolute_u16(char registry);
uint8_t NES::getIndirectX_u8();
uint8_t NES::getIndirectY_u8();
//TODO: implied, relative, indirect (Indirect might be resolved inside JMP)
//TODO: those that can one up the cycle need to get a out variable or class-lvl variable that they can access.


uint8_t getInmeditate_u8(){ return fetch(); }
uint8_t getZeroPage_u8(){
	uint8_t zpd = fetch();
	return memory[zpd];
}
uint8_t getZeroPage_u8(char registry){
	uint8_t reg;
	
	switch(registry)
	{
	case 'X':
		reg = cpuRegistry.registry.X;
		break;
	case 'Y':
		reg = cpuRegistry.registry.Y;
		break;
	}
	uint8_t zpd = fetch() + reg; //check x
	return memory[zpd];
}
uint16_t getAbsolute_u16(){
	uint16_t ad = fetch16();
	return memory[ad];
}
uint16_t getAbsolute_u16(char registry){
	uint8_t reg;
	
	switch(registry)
	{
	case 'X':
		reg = cpuRegistry.registry.X;
		break;
	case 'Y':
		reg = cpuRegistry.registry.Y;
		break;
	}

	uint16_t ad = fetch16 + reg;
	return ad;
}
uint8_t getIndirectX_u8(){
	uint8_t inzp = fetch() + cpuRegistry.registry.X;
	uint8_t idl = memory[inzp];
	uint8_t idh = memory[inzp + 1];
	//TODO: little/big endian comparer (currently in little endian format)
	
	uint16_t id |= idl;
	id |= (idh << 8);
	return memory[id];
}
uint8_t getIndirectY_u8(){
	uint8_t inzp = fetch();
	uint8_t idl = memory[inzp];
	uint8_t idh = memory[inzp + 1];
	//TODO: little/big endian comparer (currently in little endian format)	
	uint16_t id |= idl;
	id |= (idh << 8);
	return memory[id + cpuRegistry.registry.Y];
}
/*uint8_t getDataFromMode_u8(... &mode){
	uint8_t M = NULL;
	switch(mode)
	{
		M = ?;
	}
	return M;
}*/
uint16_t getDataFromMode_u16(... &mode){ 
	
	//TODO: think of better format to select between fetching address space or memory.
	/*
		the M can both be used directly and as allocation of an address space.
		the best thing to do is to alter the fetch to return the address instead of the value.
		M will be returned as a 16 bit byte. this should then be used as memory=[&r16bit].
		
		or M should be treated per type.
		
		if(immediate) {direct} else {address}
	*/
	
	uint16_t M = NULL;
	switch(mode)
	{
		M = ?;
	}
	return M; //16 bit M should shift the low bytes into a 8 bit value.
}

int LDA(... &mode)
{
	uint8_t M = NULL;
	M = getDataFromMode_u16(mode);
	cpuRegistry.registry.A = M;
	SET_ZN(cpuRegistry.registry.A);
}

int ADC(... &mode)
{
	uint8_t M = NULL;
	M = getDataFromMode_u16(mode);
	//TODO: determine what sets carry and overflow
	/*
	 C = A^M && C^M ... orz 
	*/
	cpuRegistry.registry.A = cpuRegistry.registry.A + M + cpuRegistry.p.C;
	SET_ZN(cpuRegistry.registry.A);
}

int AND(... &mode)
{
	uint8_t M = NULL;
	M = getDataFromMode_u16(mode);
	cpuRegistry.registry.A = cpuRegistry.registry.A && M;
	SET_ZN(cpuRegistry.registry.A);
}

int ASL(... &mode)
{
	if(mode == Accumulator)
	{
		cpuRegistry.p.C = ((cpuRegistry.registry.A >> 7) &0x01);
		cpuRegistry.registry.A = (cpuRegistry.registry.A << 1);
		SET_ZN(cpuRegistry.registry.A);
	}
	else
	{
		uint16_t memoryLocation = getAddressFromMode_u16(mode); //required to be in a u16 slot
		cpuRegistry.p.C = ((memory[memoryLocation] >> 7) &0x01);
		memory[memoryLocation] = (memory[memoryLocation] << 1);
		SET_ZN(memory[memoryLocation]);
	}
}

int BIT(... &mode)
{
	uint8_t M = NULL;
	M = getDataFromMode_u16(mode);
	
	uint8_t checksum = cpuRegistry.registry.A && <;
	(checksum >> 7) & 1? setNegative() : unsetNegative(); //override standard negative check.
	(checksum >> 6) & 1? sev() : clv();
}

int CMP_ALL(... &mode, char reg)
{
	uint8_t reg;
	uint8_t M = NULL;
	uint8_t result = 0xFF;
	
	switch(registry)
	{
	case 'X':
		reg = cpuRegistry.registry.X;
		break;
	case 'Y':
		reg = cpuRegistry.registry.Y;
		break;
	case 'A':
		reg = cpuRegistry.registry.A;
		break;
	}
	
	M = getDataFromMode_u16(mode);
	
	( reg >= M ) ? sec() : clc();
	( reg == M ) ? setZero() : unsetZero(); //override zero check;
	result = reg;
	result -= M;
	setNegative(result);
}

int EOR(... &mode)
{
	uint8_t M = NULL;
	M = getDataFromMode_u16(mode);
	cpuRegistry.registry.A = cpuRegistry.registry.A ^ M;
}

int INC(... &mode)
{
	uint16_t M = NULL;
	M = getDataFromMode_u16(mode);
	memory[data] = memory[data] + 1;
}

int DEC(... &mode)
{
	uint16_t M = NULL;
	M = getDataFromMode_u16(mode);
	memory[data] = memory[data] - 1;
}

int JSR
{
	//check if you need to PUSH (PC+2) | (PC-1) and if it needs to be the PC on load - 1 / + 2 or after reading OP+1 & OP+2.
}

int LSR() //LSL
{
}

int ORA()
{
}

int ROL()
{
}

int ROR()
{
}

int RTI()
{
}

int RTS()
{
}

int SBC()
{
}

int STA() //STX //STY
{
}

int TXS() //TYS //TXA //TYA --orz
{
}

